.TH "MPU6050" 3 "Tue Jul 22 2014" "Version 1.0" "Cubeception" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MPU6050 \- 
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMPU6050\fP ()"
.br
.ti -1c
.RI "\fBMPU6050\fP (uint8_t address)"
.br
.ti -1c
.RI "uint8_t \fBgetAddress\fP ()"
.br
.ti -1c
.RI "void \fBinitialize\fP ()"
.br
.ti -1c
.RI "bool \fBtestConnection\fP ()"
.br
.ti -1c
.RI "uint8_t \fBgetAuxVDDIOLevel\fP ()"
.br
.ti -1c
.RI "void \fBsetAuxVDDIOLevel\fP (uint8_t level)"
.br
.ti -1c
.RI "uint8_t \fBgetRate\fP ()"
.br
.ti -1c
.RI "void \fBsetRate\fP (uint8_t rate)"
.br
.ti -1c
.RI "uint8_t \fBcheckMagStatus\fP ()"
.br
.ti -1c
.RI "uint8_t \fBgetExternalFrameSync\fP ()"
.br
.ti -1c
.RI "void \fBsetExternalFrameSync\fP (uint8_t sync)"
.br
.ti -1c
.RI "uint8_t \fBgetDLPFMode\fP ()"
.br
.ti -1c
.RI "void \fBsetDLPFMode\fP (uint8_t bandwidth)"
.br
.ti -1c
.RI "uint8_t \fBgetFullScaleGyroRange\fP ()"
.br
.ti -1c
.RI "void \fBsetFullScaleGyroRange\fP (uint8_t range)"
.br
.ti -1c
.RI "bool \fBgetAccelXSelfTest\fP ()"
.br
.ti -1c
.RI "void \fBsetAccelXSelfTest\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetAccelYSelfTest\fP ()"
.br
.ti -1c
.RI "void \fBsetAccelYSelfTest\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetAccelZSelfTest\fP ()"
.br
.ti -1c
.RI "void \fBsetAccelZSelfTest\fP (bool enabled)"
.br
.ti -1c
.RI "uint8_t \fBgetFullScaleAccelRange\fP ()"
.br
.ti -1c
.RI "void \fBsetFullScaleAccelRange\fP (uint8_t range)"
.br
.ti -1c
.RI "uint8_t \fBgetDHPFMode\fP ()"
.br
.ti -1c
.RI "void \fBsetDHPFMode\fP (uint8_t mode)"
.br
.ti -1c
.RI "uint8_t \fBgetFreefallDetectionThreshold\fP ()"
.br
.ti -1c
.RI "void \fBsetFreefallDetectionThreshold\fP (uint8_t threshold)"
.br
.ti -1c
.RI "uint8_t \fBgetFreefallDetectionDuration\fP ()"
.br
.ti -1c
.RI "void \fBsetFreefallDetectionDuration\fP (uint8_t duration)"
.br
.ti -1c
.RI "uint8_t \fBgetMotionDetectionThreshold\fP ()"
.br
.ti -1c
.RI "void \fBsetMotionDetectionThreshold\fP (uint8_t threshold)"
.br
.ti -1c
.RI "uint8_t \fBgetMotionDetectionDuration\fP ()"
.br
.ti -1c
.RI "void \fBsetMotionDetectionDuration\fP (uint8_t duration)"
.br
.ti -1c
.RI "uint8_t \fBgetZeroMotionDetectionThreshold\fP ()"
.br
.ti -1c
.RI "void \fBsetZeroMotionDetectionThreshold\fP (uint8_t threshold)"
.br
.ti -1c
.RI "uint8_t \fBgetZeroMotionDetectionDuration\fP ()"
.br
.ti -1c
.RI "void \fBsetZeroMotionDetectionDuration\fP (uint8_t duration)"
.br
.ti -1c
.RI "bool \fBgetTempFIFOEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetTempFIFOEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetXGyroFIFOEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetXGyroFIFOEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetYGyroFIFOEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetYGyroFIFOEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetZGyroFIFOEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetZGyroFIFOEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetAccelFIFOEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetAccelFIFOEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetSlave2FIFOEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetSlave2FIFOEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetSlave1FIFOEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetSlave1FIFOEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetSlave0FIFOEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetSlave0FIFOEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetMultiMasterEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetMultiMasterEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetWaitForExternalSensorEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetWaitForExternalSensorEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetSlave3FIFOEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetSlave3FIFOEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetSlaveReadWriteTransitionEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetSlaveReadWriteTransitionEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "uint8_t \fBgetMasterClockSpeed\fP ()"
.br
.ti -1c
.RI "void \fBsetMasterClockSpeed\fP (uint8_t speed)"
.br
.ti -1c
.RI "uint8_t \fBgetSlaveAddress\fP (uint8_t num)"
.br
.ti -1c
.RI "void \fBsetSlaveAddress\fP (uint8_t num, uint8_t address)"
.br
.ti -1c
.RI "uint8_t \fBgetSlaveRegister\fP (uint8_t num)"
.br
.ti -1c
.RI "void \fBsetSlaveRegister\fP (uint8_t num, uint8_t reg)"
.br
.ti -1c
.RI "bool \fBgetSlaveEnabled\fP (uint8_t num)"
.br
.ti -1c
.RI "void \fBsetSlaveEnabled\fP (uint8_t num, bool enabled)"
.br
.ti -1c
.RI "bool \fBgetSlaveWordByteSwap\fP (uint8_t num)"
.br
.ti -1c
.RI "void \fBsetSlaveWordByteSwap\fP (uint8_t num, bool enabled)"
.br
.ti -1c
.RI "bool \fBgetSlaveWriteMode\fP (uint8_t num)"
.br
.ti -1c
.RI "void \fBsetSlaveWriteMode\fP (uint8_t num, bool mode)"
.br
.ti -1c
.RI "bool \fBgetSlaveWordGroupOffset\fP (uint8_t num)"
.br
.ti -1c
.RI "void \fBsetSlaveWordGroupOffset\fP (uint8_t num, bool enabled)"
.br
.ti -1c
.RI "uint8_t \fBgetSlaveDataLength\fP (uint8_t num)"
.br
.ti -1c
.RI "void \fBsetSlaveDataLength\fP (uint8_t num, uint8_t length)"
.br
.ti -1c
.RI "uint8_t \fBgetSlave4Address\fP ()"
.br
.ti -1c
.RI "void \fBsetSlave4Address\fP (uint8_t address)"
.br
.ti -1c
.RI "uint8_t \fBgetSlave4Register\fP ()"
.br
.ti -1c
.RI "void \fBsetSlave4Register\fP (uint8_t reg)"
.br
.ti -1c
.RI "void \fBsetSlave4OutputByte\fP (uint8_t data)"
.br
.ti -1c
.RI "bool \fBgetSlave4Enabled\fP ()"
.br
.ti -1c
.RI "void \fBsetSlave4Enabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetSlave4InterruptEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetSlave4InterruptEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetSlave4WriteMode\fP ()"
.br
.ti -1c
.RI "void \fBsetSlave4WriteMode\fP (bool mode)"
.br
.ti -1c
.RI "uint8_t \fBgetSlave4MasterDelay\fP ()"
.br
.ti -1c
.RI "void \fBsetSlave4MasterDelay\fP (uint8_t delay)"
.br
.ti -1c
.RI "uint8_t \fBgetSlate4InputByte\fP ()"
.br
.ti -1c
.RI "bool \fBgetPassthroughStatus\fP ()"
.br
.ti -1c
.RI "bool \fBgetSlave4IsDone\fP ()"
.br
.ti -1c
.RI "bool \fBgetLostArbitration\fP ()"
.br
.ti -1c
.RI "bool \fBgetSlave4Nack\fP ()"
.br
.ti -1c
.RI "bool \fBgetSlave3Nack\fP ()"
.br
.ti -1c
.RI "bool \fBgetSlave2Nack\fP ()"
.br
.ti -1c
.RI "bool \fBgetSlave1Nack\fP ()"
.br
.ti -1c
.RI "bool \fBgetSlave0Nack\fP ()"
.br
.ti -1c
.RI "bool \fBgetInterruptMode\fP ()"
.br
.ti -1c
.RI "void \fBsetInterruptMode\fP (bool mode)"
.br
.ti -1c
.RI "bool \fBgetInterruptDrive\fP ()"
.br
.ti -1c
.RI "void \fBsetInterruptDrive\fP (bool drive)"
.br
.ti -1c
.RI "bool \fBgetInterruptLatch\fP ()"
.br
.ti -1c
.RI "void \fBsetInterruptLatch\fP (bool latch)"
.br
.ti -1c
.RI "bool \fBgetInterruptLatchClear\fP ()"
.br
.ti -1c
.RI "void \fBsetInterruptLatchClear\fP (bool clear)"
.br
.ti -1c
.RI "bool \fBgetFSyncInterruptLevel\fP ()"
.br
.ti -1c
.RI "void \fBsetFSyncInterruptLevel\fP (bool level)"
.br
.ti -1c
.RI "bool \fBgetFSyncInterruptEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetFSyncInterruptEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetI2CBypassEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetI2CBypassEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetClockOutputEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetClockOutputEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "uint8_t \fBgetIntEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetIntEnabled\fP (uint8_t enabled)"
.br
.ti -1c
.RI "bool \fBgetIntFreefallEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetIntFreefallEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetIntMotionEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetIntMotionEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetIntZeroMotionEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetIntZeroMotionEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetIntFIFOBufferOverflowEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetIntFIFOBufferOverflowEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetIntI2CMasterEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetIntI2CMasterEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetIntDataReadyEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetIntDataReadyEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "uint8_t \fBgetIntStatus\fP ()"
.br
.ti -1c
.RI "bool \fBgetIntFreefallStatus\fP ()"
.br
.ti -1c
.RI "bool \fBgetIntMotionStatus\fP ()"
.br
.ti -1c
.RI "bool \fBgetIntZeroMotionStatus\fP ()"
.br
.ti -1c
.RI "bool \fBgetIntFIFOBufferOverflowStatus\fP ()"
.br
.ti -1c
.RI "bool \fBgetIntI2CMasterStatus\fP ()"
.br
.ti -1c
.RI "bool \fBgetIntDataReadyStatus\fP ()"
.br
.ti -1c
.RI "void \fBgetMotion9\fP (int16_t *ax, int16_t *ay, int16_t *az, int16_t *gx, int16_t *gy, int16_t *gz, int16_t *mx, int16_t *my, int16_t *mz)"
.br
.ti -1c
.RI "void \fBgetMotion6\fP (int16_t *ax, int16_t *ay, int16_t *az, int16_t *gx, int16_t *gy, int16_t *gz)"
.br
.ti -1c
.RI "void \fBgetAcceleration\fP (int16_t *x, int16_t *y, int16_t *z)"
.br
.ti -1c
.RI "int16_t \fBgetAccelerationX\fP ()"
.br
.ti -1c
.RI "int16_t \fBgetAccelerationY\fP ()"
.br
.ti -1c
.RI "int16_t \fBgetAccelerationZ\fP ()"
.br
.ti -1c
.RI "int16_t \fBgetTemperature\fP ()"
.br
.ti -1c
.RI "void \fBgetRotation\fP (int16_t *x, int16_t *y, int16_t *z)"
.br
.ti -1c
.RI "int16_t \fBgetRotationX\fP ()"
.br
.ti -1c
.RI "int16_t \fBgetRotationY\fP ()"
.br
.ti -1c
.RI "int16_t \fBgetRotationZ\fP ()"
.br
.ti -1c
.RI "void \fBgetMag\fP (int16_t *x, int16_t *y, int16_t *z)"
.br
.ti -1c
.RI "uint8_t \fBgetExternalSensorByte\fP (int position)"
.br
.ti -1c
.RI "uint16_t \fBgetExternalSensorWord\fP (int position)"
.br
.ti -1c
.RI "uint32_t \fBgetExternalSensorDWord\fP (int position)"
.br
.ti -1c
.RI "bool \fBgetXNegMotionDetected\fP ()"
.br
.ti -1c
.RI "bool \fBgetXPosMotionDetected\fP ()"
.br
.ti -1c
.RI "bool \fBgetYNegMotionDetected\fP ()"
.br
.ti -1c
.RI "bool \fBgetYPosMotionDetected\fP ()"
.br
.ti -1c
.RI "bool \fBgetZNegMotionDetected\fP ()"
.br
.ti -1c
.RI "bool \fBgetZPosMotionDetected\fP ()"
.br
.ti -1c
.RI "bool \fBgetZeroMotionDetected\fP ()"
.br
.ti -1c
.RI "void \fBsetSlaveOutputByte\fP (uint8_t num, uint8_t data)"
.br
.ti -1c
.RI "bool \fBgetExternalShadowDelayEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetExternalShadowDelayEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetSlaveDelayEnabled\fP (uint8_t num)"
.br
.ti -1c
.RI "void \fBsetSlaveDelayEnabled\fP (uint8_t num, bool enabled)"
.br
.ti -1c
.RI "void \fBresetGyroscopePath\fP ()"
.br
.ti -1c
.RI "void \fBresetAccelerometerPath\fP ()"
.br
.ti -1c
.RI "void \fBresetTemperaturePath\fP ()"
.br
.ti -1c
.RI "uint8_t \fBgetAccelerometerPowerOnDelay\fP ()"
.br
.ti -1c
.RI "void \fBsetAccelerometerPowerOnDelay\fP (uint8_t delay)"
.br
.ti -1c
.RI "uint8_t \fBgetFreefallDetectionCounterDecrement\fP ()"
.br
.ti -1c
.RI "void \fBsetFreefallDetectionCounterDecrement\fP (uint8_t decrement)"
.br
.ti -1c
.RI "uint8_t \fBgetMotionDetectionCounterDecrement\fP ()"
.br
.ti -1c
.RI "void \fBsetMotionDetectionCounterDecrement\fP (uint8_t decrement)"
.br
.ti -1c
.RI "bool \fBgetFIFOEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetFIFOEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetI2CMasterModeEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetI2CMasterModeEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBswitchSPIEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBresetFIFO\fP ()"
.br
.ti -1c
.RI "void \fBresetI2CMaster\fP ()"
.br
.ti -1c
.RI "void \fBresetSensors\fP ()"
.br
.ti -1c
.RI "void \fBreset\fP ()"
.br
.ti -1c
.RI "bool \fBgetSleepEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetSleepEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetWakeCycleEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetWakeCycleEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetTempSensorEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetTempSensorEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "uint8_t \fBgetClockSource\fP ()"
.br
.ti -1c
.RI "void \fBsetClockSource\fP (uint8_t source)"
.br
.ti -1c
.RI "uint8_t \fBgetWakeFrequency\fP ()"
.br
.ti -1c
.RI "void \fBsetWakeFrequency\fP (uint8_t frequency)"
.br
.ti -1c
.RI "bool \fBgetStandbyXAccelEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetStandbyXAccelEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetStandbyYAccelEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetStandbyYAccelEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetStandbyZAccelEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetStandbyZAccelEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetStandbyXGyroEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetStandbyXGyroEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetStandbyYGyroEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetStandbyYGyroEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetStandbyZGyroEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetStandbyZGyroEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "uint16_t \fBgetFIFOCount\fP ()"
.br
.ti -1c
.RI "uint8_t \fBgetFIFOByte\fP ()"
.br
.ti -1c
.RI "void \fBsetFIFOByte\fP (uint8_t data)"
.br
.ti -1c
.RI "void \fBgetFIFOBytes\fP (uint8_t *data, uint8_t length)"
.br
.ti -1c
.RI "uint8_t \fBgetDeviceID\fP ()"
.br
.ti -1c
.RI "void \fBsetDeviceID\fP (uint8_t id)"
.br
.ti -1c
.RI "uint8_t \fBgetOTPBankValid\fP ()"
.br
.ti -1c
.RI "void \fBsetOTPBankValid\fP (bool enabled)"
.br
.ti -1c
.RI "int8_t \fBgetXGyroOffset\fP ()"
.br
.ti -1c
.RI "void \fBsetXGyroOffset\fP (int8_t offset)"
.br
.ti -1c
.RI "int8_t \fBgetYGyroOffset\fP ()"
.br
.ti -1c
.RI "void \fBsetYGyroOffset\fP (int8_t offset)"
.br
.ti -1c
.RI "int8_t \fBgetZGyroOffset\fP ()"
.br
.ti -1c
.RI "void \fBsetZGyroOffset\fP (int8_t offset)"
.br
.ti -1c
.RI "int8_t \fBgetXFineGain\fP ()"
.br
.ti -1c
.RI "void \fBsetXFineGain\fP (int8_t gain)"
.br
.ti -1c
.RI "int8_t \fBgetYFineGain\fP ()"
.br
.ti -1c
.RI "void \fBsetYFineGain\fP (int8_t gain)"
.br
.ti -1c
.RI "int8_t \fBgetZFineGain\fP ()"
.br
.ti -1c
.RI "void \fBsetZFineGain\fP (int8_t gain)"
.br
.ti -1c
.RI "int16_t \fBgetXAccelOffset\fP ()"
.br
.ti -1c
.RI "void \fBsetXAccelOffset\fP (int16_t offset)"
.br
.ti -1c
.RI "int16_t \fBgetYAccelOffset\fP ()"
.br
.ti -1c
.RI "void \fBsetYAccelOffset\fP (int16_t offset)"
.br
.ti -1c
.RI "int16_t \fBgetZAccelOffset\fP ()"
.br
.ti -1c
.RI "void \fBsetZAccelOffset\fP (int16_t offset)"
.br
.ti -1c
.RI "int16_t \fBgetXGyroOffsetUser\fP ()"
.br
.ti -1c
.RI "void \fBsetXGyroOffsetUser\fP (int16_t offset)"
.br
.ti -1c
.RI "int16_t \fBgetYGyroOffsetUser\fP ()"
.br
.ti -1c
.RI "void \fBsetYGyroOffsetUser\fP (int16_t offset)"
.br
.ti -1c
.RI "int16_t \fBgetZGyroOffsetUser\fP ()"
.br
.ti -1c
.RI "void \fBsetZGyroOffsetUser\fP (int16_t offset)"
.br
.ti -1c
.RI "bool \fBgetIntPLLReadyEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetIntPLLReadyEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetIntDMPEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetIntDMPEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "bool \fBgetDMPInt5Status\fP ()"
.br
.ti -1c
.RI "bool \fBgetDMPInt4Status\fP ()"
.br
.ti -1c
.RI "bool \fBgetDMPInt3Status\fP ()"
.br
.ti -1c
.RI "bool \fBgetDMPInt2Status\fP ()"
.br
.ti -1c
.RI "bool \fBgetDMPInt1Status\fP ()"
.br
.ti -1c
.RI "bool \fBgetDMPInt0Status\fP ()"
.br
.ti -1c
.RI "bool \fBgetIntPLLReadyStatus\fP ()"
.br
.ti -1c
.RI "bool \fBgetIntDMPStatus\fP ()"
.br
.ti -1c
.RI "bool \fBgetDMPEnabled\fP ()"
.br
.ti -1c
.RI "void \fBsetDMPEnabled\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBresetDMP\fP ()"
.br
.ti -1c
.RI "void \fBsetMemoryBank\fP (uint8_t bank, bool prefetchEnabled=false, bool userBank=false)"
.br
.ti -1c
.RI "void \fBsetMemoryStartAddress\fP (uint8_t address)"
.br
.ti -1c
.RI "uint8_t \fBreadMemoryByte\fP ()"
.br
.ti -1c
.RI "void \fBwriteMemoryByte\fP (uint8_t data)"
.br
.ti -1c
.RI "void \fBreadMemoryBlock\fP (uint8_t *data, uint16_t dataSize, uint8_t bank=0, uint8_t address=0)"
.br
.ti -1c
.RI "bool \fBwriteMemoryBlock\fP (const uint8_t *data, uint16_t dataSize, uint8_t bank=0, uint8_t address=0, bool verify=true, bool useProgMem=false)"
.br
.ti -1c
.RI "bool \fBwriteProgMemoryBlock\fP (const uint8_t *data, uint16_t dataSize, uint8_t bank=0, uint8_t address=0, bool verify=true)"
.br
.ti -1c
.RI "bool \fBwriteDMPConfigurationSet\fP (const uint8_t *data, uint16_t dataSize, bool useProgMem=false)"
.br
.ti -1c
.RI "bool \fBwriteProgDMPConfigurationSet\fP (const uint8_t *data, uint16_t dataSize)"
.br
.ti -1c
.RI "uint8_t \fBgetDMPConfig1\fP ()"
.br
.ti -1c
.RI "void \fBsetDMPConfig1\fP (uint8_t config)"
.br
.ti -1c
.RI "uint8_t \fBgetDMPConfig2\fP ()"
.br
.ti -1c
.RI "void \fBsetDMPConfig2\fP (uint8_t config)"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "MPU6050::MPU6050 ()"
Default constructor, uses default I2C address\&. 
.PP
\fBSee also:\fP
.RS 4
MPU6050_DEFAULT_ADDRESS 
.RE
.PP

.SS "MPU6050::MPU6050 (uint8_taddress)"
Specific address constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIaddress\fP I2C address 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_DEFAULT_ADDRESS 
.PP
MPU6050_ADDRESS_AD0_LOW 
.PP
MPU6050_ADDRESS_AD0_HIGH 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void MPU6050::getAcceleration (int16_t *x, int16_t *y, int16_t *z)"
Get 3-axis accelerometer readings\&. These registers store the most recent accelerometer measurements\&. Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25\&.
.PP
The accelerometer measurement registers, along with the temperature measurement registers, gyroscope measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set\&.
.PP
The data within the accelerometer sensors' internal register set is always updated at the Sample Rate\&. Meanwhile, the user-facing read register set duplicates the internal register set's data values whenever the serial interface is idle\&. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant\&. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt\&.
.PP
Each 16-bit accelerometer measurement has a full scale defined in ACCEL_FS (Register 28)\&. For each full scale setting, the accelerometers' sensitivity per LSB in ACCEL_xOUT is shown in the table below:
.PP
.PP
.nf

AFS_SEL | Full Scale Range | LSB Sensitivity
--------+------------------+----------------
0       | +/- 2g           | 8192 LSB/mg
1       | +/- 4g           | 4096 LSB/mg
2       | +/- 8g           | 2048 LSB/mg
3       | +/- 16g          | 1024 LSB/mg
.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fIx\fP 16-bit signed integer container for X-axis acceleration 
.br
\fIy\fP 16-bit signed integer container for Y-axis acceleration 
.br
\fIz\fP 16-bit signed integer container for Z-axis acceleration 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_GYRO_XOUT_H 
.RE
.PP

.SS "int16_t MPU6050::getAccelerationX ()"
Get X-axis accelerometer reading\&. 
.PP
\fBReturns:\fP
.RS 4
X-axis acceleration measurement in 16-bit 2's complement format 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetMotion6()\fP 
.PP
MPU6050_RA_ACCEL_XOUT_H 
.RE
.PP

.SS "int16_t MPU6050::getAccelerationY ()"
Get Y-axis accelerometer reading\&. 
.PP
\fBReturns:\fP
.RS 4
Y-axis acceleration measurement in 16-bit 2's complement format 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetMotion6()\fP 
.PP
MPU6050_RA_ACCEL_YOUT_H 
.RE
.PP

.SS "int16_t MPU6050::getAccelerationZ ()"
Get Z-axis accelerometer reading\&. 
.PP
\fBReturns:\fP
.RS 4
Z-axis acceleration measurement in 16-bit 2's complement format 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetMotion6()\fP 
.PP
MPU6050_RA_ACCEL_ZOUT_H 
.RE
.PP

.SS "uint8_t MPU6050::getAccelerometerPowerOnDelay ()"
Get accelerometer power-on delay\&. The accelerometer data path provides samples to the sensor registers, Motion detection, Zero Motion detection, and Free Fall detection modules\&. The signal path contains filters which must be flushed on wake-up with new samples before the detection modules begin operations\&. The default wake-up delay, of 4ms can be lengthened by up to 3ms\&. This additional delay is specified in ACCEL_ON_DELAY in units of 1 LSB = 1 ms\&. The user may select any value above zero unless instructed otherwise by InvenSense\&. Please refer to Section 8 of the MPU-6000/MPU-6050 Product Specification document for further information regarding the detection modules\&. 
.PP
\fBReturns:\fP
.RS 4
Current accelerometer power-on delay 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_MOT_DETECT_CTRL 
.PP
MPU6050_DETECT_ACCEL_ON_DELAY_BIT 
.RE
.PP

.SS "bool MPU6050::getAccelFIFOEnabled ()"
Get accelerometer FIFO enabled value\&. When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H, ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59 to 64) to be written into the FIFO buffer\&. 
.PP
\fBReturns:\fP
.RS 4
Current accelerometer FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "bool MPU6050::getAccelXSelfTest ()"
Get self-test enabled setting for accelerometer X axis\&. 
.PP
\fBReturns:\fP
.RS 4
Self-test enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_ACCEL_CONFIG 
.RE
.PP

.SS "bool MPU6050::getAccelYSelfTest ()"
Get self-test enabled value for accelerometer Y axis\&. 
.PP
\fBReturns:\fP
.RS 4
Self-test enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_ACCEL_CONFIG 
.RE
.PP

.SS "bool MPU6050::getAccelZSelfTest ()"
Get self-test enabled value for accelerometer Z axis\&. 
.PP
\fBReturns:\fP
.RS 4
Self-test enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_ACCEL_CONFIG 
.RE
.PP

.SS "uint8_t MPU6050::getAuxVDDIOLevel ()"
Get the auxiliary I2C supply voltage level\&. When set to 1, the auxiliary I2C bus high logic level is VDD\&. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC\&. This does not apply to the MPU-6000, which does not have a VLOGIC pin\&. 
.PP
\fBReturns:\fP
.RS 4
I2C supply voltage level (0=VLOGIC, 1=VDD) 
.RE
.PP

.SS "bool MPU6050::getClockOutputEnabled ()"
Get reference clock output enabled status\&. When this bit is equal to 1, a reference clock output is provided at the CLKOUT pin\&. When this bit is equal to 0, the clock output is disabled\&. For further information regarding CLKOUT, please refer to the MPU-60X0 Product Specification document\&. 
.PP
\fBReturns:\fP
.RS 4
Current reference clock output enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_CLKOUT_EN_BIT 
.RE
.PP

.SS "uint8_t MPU6050::getClockSource ()"
Get clock source setting\&. 
.PP
\fBReturns:\fP
.RS 4
Current clock source setting 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_PWR_MGMT_1 
.PP
MPU6050_PWR1_CLKSEL_BIT 
.PP
MPU6050_PWR1_CLKSEL_LENGTH 
.RE
.PP

.SS "uint8_t MPU6050::getDHPFMode ()"
Get the high-pass filter configuration\&. The DHPF is a filter module in the path leading to motion detectors (Free Fall, Motion threshold, and Zero Motion)\&. The high pass filter output is not available to the data registers (see Figure in Section 8 of the MPU-6000/ MPU-6050 Product Specification document)\&.
.PP
The high pass filter has three modes:
.PP
.PP
.nf

   Reset: The filter output settles to zero within one sample\&. This
          effectively disables the high pass filter\&. This mode may be toggled
          to quickly settle the filter\&.
.fi
.PP
.PP
.PP
.nf
   On:    The high pass filter will pass signals above the cut off frequency\&.
.fi
.PP
.PP
.PP
.nf
   Hold:  When triggered, the filter holds the present sample\&. The filter
          output will be the difference between the input sample and the held
          sample\&.
.fi
.PP
.PP
.PP
.nf

ACCEL_HPF | Filter Mode | Cut-off Frequency
----------+-------------+------------------
0         | Reset       | None
1         | On          | 5Hz
2         | On          | 2\&.5Hz
3         | On          | 1\&.25Hz
4         | On          | 0\&.63Hz
7         | Hold        | None
.fi
.PP
.PP
\fBReturns:\fP
.RS 4
Current high-pass filter configuration 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_DHPF_RESET 
.PP
MPU6050_RA_ACCEL_CONFIG 
.RE
.PP

.SS "uint8_t MPU6050::getDLPFMode ()"
Get digital low-pass filter configuration\&. The DLPF_CFG parameter sets the digital low pass filter configuration\&. It also determines the internal sampling rate used by the device as shown in the table below\&.
.PP
Note: The accelerometer output rate is 1kHz\&. This means that for a Sample Rate greater than 1kHz, the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once\&.
.PP
.PP
.nf

         |   ACCELEROMETER    |           GYROSCOPE
DLPF_CFG | Bandwidth | Delay  | Bandwidth | Delay  | Sample Rate
---------+-----------+--------+-----------+--------+-------------
0        | 260Hz     | 0ms    | 256Hz     | 0\&.98ms | 8kHz
1        | 184Hz     | 2\&.0ms  | 188Hz     | 1\&.9ms  | 1kHz
2        | 94Hz      | 3\&.0ms  | 98Hz      | 2\&.8ms  | 1kHz
3        | 44Hz      | 4\&.9ms  | 42Hz      | 4\&.8ms  | 1kHz
4        | 21Hz      | 8\&.5ms  | 20Hz      | 8\&.3ms  | 1kHz
5        | 10Hz      | 13\&.8ms | 10Hz      | 13\&.4ms | 1kHz
6        | 5Hz       | 19\&.0ms | 5Hz       | 18\&.6ms | 1kHz
7        |   -- Reserved --   |   -- Reserved --   | Reserved
.fi
.PP
.PP
\fBReturns:\fP
.RS 4
DLFP configuration 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_CONFIG 
.PP
MPU6050_CFG_DLPF_CFG_BIT 
.PP
MPU6050_CFG_DLPF_CFG_LENGTH 
.RE
.PP

.SS "uint8_t MPU6050::getExternalFrameSync ()"
Get external FSYNC configuration\&. Configures the external Frame Synchronization (FSYNC) pin sampling\&. An external signal connected to the FSYNC pin can be sampled by configuring EXT_SYNC_SET\&. Signal changes to the FSYNC pin are latched so that short strobes may be captured\&. The latched FSYNC signal will be sampled at the Sampling Rate, as defined in register 25\&. After sampling, the latch will reset to the current FSYNC signal state\&.
.PP
The sampled value will be reported in place of the least significant bit in a sensor data register determined by the value of EXT_SYNC_SET according to the following table\&.
.PP
.PP
.nf

EXT_SYNC_SET | FSYNC Bit Location
-------------+-------------------
0            | Input disabled
1            | TEMP_OUT_L[0]
2            | GYRO_XOUT_L[0]
3            | GYRO_YOUT_L[0]
4            | GYRO_ZOUT_L[0]
5            | ACCEL_XOUT_L[0]
6            | ACCEL_YOUT_L[0]
7            | ACCEL_ZOUT_L[0]
.fi
.PP
.PP
\fBReturns:\fP
.RS 4
FSYNC configuration value 
.RE
.PP

.SS "uint8_t MPU6050::getExternalSensorByte (intposition)"
Read single byte from external sensor data register\&. These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface\&. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53)\&.
.PP
External sensor data is written to these registers at the Sample Rate as defined in Register 25\&. This access rate can be reduced by using the Slave Delay Enable registers (Register 103)\&.
.PP
External sensor data registers, along with the gyroscope measurement registers, accelerometer measurement registers, and temperature measurement registers, are composed of two sets of registers: an internal register set and a user-facing read register set\&.
.PP
The data within the external sensors' internal register set is always updated at the Sample Rate (or the reduced access rate) whenever the serial interface is idle\&. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant\&. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt\&.
.PP
Data is placed in these external sensor data registers according to I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_CTRL (Registers 39, 42, 45, and 48)\&. When more than zero bytes are read (I2C_SLVx_LEN > 0) from an enabled slave (I2C_SLVx_EN = 1), the slave is read at the Sample Rate (as defined in Register 25) or delayed rate (if specified in Register 52 and 103)\&. During each Sample cycle, slave reads are performed in order of Slave number\&. If all slaves are enabled with more than zero bytes to be read, the order will be Slave 0, followed by Slave 1, Slave 2, and Slave 3\&.
.PP
Each enabled slave will have EXT_SENS_DATA registers associated with it by number of bytes read (I2C_SLVx_LEN) in order of slave number, starting from EXT_SENS_DATA_00\&. Note that this means enabling or disabling a slave may change the higher numbered slaves' associated registers\&. Furthermore, if fewer total bytes are being read from the external sensors as a result of such a change, then the data remaining in the registers which no longer have an associated slave device (i\&.e\&. high numbered registers) will remain in these previously allocated registers unless reset\&.
.PP
If the sum of the read lengths of all SLVx transactions exceed the number of available EXT_SENS_DATA registers, the excess bytes will be dropped\&. There are 24 EXT_SENS_DATA registers and hence the total read lengths between all the slaves cannot be greater than 24 or some bytes will be lost\&.
.PP
Note: Slave 4's behavior is distinct from that of Slaves 0-3\&. For further information regarding the characteristics of Slave 4, please refer to Registers 49 to 53\&.
.PP
EXAMPLE: Suppose that Slave 0 is enabled with 4 bytes to be read (I2C_SLV0_EN = 1 and I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 bytes to be read so that I2C_SLV1_EN = 1 and I2C_SLV1_LEN = 2\&. In such a situation, EXT_SENS_DATA _00 through _03 will be associated with Slave 0, while EXT_SENS_DATA _04 and 05 will be associated with Slave 1\&. If Slave 2 is enabled as well, registers starting from EXT_SENS_DATA_06 will be allocated to Slave 2\&.
.PP
If Slave 2 is disabled while Slave 3 is enabled in this same situation, then registers starting from EXT_SENS_DATA_06 will be allocated to Slave 3 instead\&.
.PP
REGISTER ALLOCATION FOR DYNAMIC DISABLE VS\&. NORMAL DISABLE: If a slave is disabled at any time, the space initially allocated to the slave in the EXT_SENS_DATA register, will remain associated with that slave\&. This is to avoid dynamic adjustment of the register allocation\&.
.PP
The allocation of the EXT_SENS_DATA registers is recomputed only when (1) all slaves are disabled, or (2) the I2C_MST_RST bit is set (Register 106)\&.
.PP
This above is also true if one of the slaves gets NACKed and stops functioning\&.
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Starting position (0-23) 
.RE
.PP
\fBReturns:\fP
.RS 4
Byte read from register 
.RE
.PP

.SS "uint32_t MPU6050::getExternalSensorDWord (intposition)"
Read double word (4 bytes) from external sensor data registers\&. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Starting position (0-20) 
.RE
.PP
\fBReturns:\fP
.RS 4
Double word read from registers 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetExternalSensorByte()\fP 
.RE
.PP

.SS "uint16_t MPU6050::getExternalSensorWord (intposition)"
Read word (2 bytes) from external sensor data registers\&. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Starting position (0-21) 
.RE
.PP
\fBReturns:\fP
.RS 4
Word read from register 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetExternalSensorByte()\fP 
.RE
.PP

.SS "bool MPU6050::getExternalShadowDelayEnabled ()"
Get external data shadow delay enabled status\&. This register is used to specify the timing of external sensor data shadowing\&. When DELAY_ES_SHADOW is set to 1, shadowing of external sensor data is delayed until all data has been received\&. 
.PP
\fBReturns:\fP
.RS 4
Current external data shadow delay enabled status\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_DELAY_CTRL 
.PP
MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT 
.RE
.PP

.SS "bool MPU6050::getFIFOEnabled ()"
Get FIFO enabled status\&. When this bit is set to 0, the FIFO buffer is disabled\&. The FIFO buffer cannot be written to or read from while disabled\&. The FIFO buffer's state does not change unless the MPU-60X0 is power cycled\&. 
.PP
\fBReturns:\fP
.RS 4
Current FIFO enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_USER_CTRL 
.PP
MPU6050_USERCTRL_FIFO_EN_BIT 
.RE
.PP

.SS "uint8_t MPU6050::getFreefallDetectionCounterDecrement ()"
Get Free Fall detection counter decrement configuration\&. Detection is registered by the Free Fall detection module after accelerometer measurements meet their respective threshold conditions over a specified number of samples\&. When the threshold conditions are met, the corresponding detection counter increments by 1\&. The user may control the rate at which the detection counter decrements when the threshold condition is not met by configuring FF_COUNT\&. The decrement rate can be set according to the following table:
.PP
.PP
.nf

FF_COUNT | Counter Decrement
---------+------------------
0        | Reset
1        | 1
2        | 2
3        | 4
.fi
.PP
.PP
When FF_COUNT is configured to 0 (reset), any non-qualifying sample will reset the counter to 0\&. For further information on Free Fall detection, please refer to Registers 29 to 32\&.
.PP
\fBReturns:\fP
.RS 4
Current decrement configuration 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_MOT_DETECT_CTRL 
.PP
MPU6050_DETECT_FF_COUNT_BIT 
.RE
.PP

.SS "uint8_t MPU6050::getFreefallDetectionDuration ()"
Get free-fall event duration threshold\&. This register configures the duration counter threshold for Free Fall event detection\&. The duration counter ticks at 1kHz, therefore FF_DUR has a unit of 1 LSB = 1 ms\&.
.PP
The Free Fall duration counter increments while the absolute value of the accelerometer measurements are each less than the detection threshold (Register 29)\&. The Free Fall interrupt is triggered when the Free Fall duration counter reaches the time specified in this register\&.
.PP
For more details on the Free Fall detection interrupt, see Section 8\&.2 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document\&.
.PP
\fBReturns:\fP
.RS 4
Current free-fall duration threshold value (LSB = 1ms) 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_FF_DUR 
.RE
.PP

.SS "uint8_t MPU6050::getFreefallDetectionThreshold ()"
Get free-fall event acceleration threshold\&. This register configures the detection threshold for Free Fall event detection\&. The unit of FF_THR is 1LSB = 2mg\&. Free Fall is detected when the absolute value of the accelerometer measurements for the three axes are each less than the detection threshold\&. This condition increments the Free Fall duration counter (Register 30)\&. The Free Fall interrupt is triggered when the Free Fall duration counter reaches the time specified in FF_DUR\&.
.PP
For more details on the Free Fall detection interrupt, see Section 8\&.2 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document\&.
.PP
\fBReturns:\fP
.RS 4
Current free-fall acceleration threshold value (LSB = 2mg) 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_FF_THR 
.RE
.PP

.SS "bool MPU6050::getFSyncInterruptEnabled ()"
Get FSYNC pin interrupt enabled setting\&. Will be set 0 for disabled, 1 for enabled\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt enabled setting 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_FSYNC_INT_EN_BIT 
.RE
.PP

.SS "bool MPU6050::getFSyncInterruptLevel ()"
Get FSYNC interrupt logic level mode\&. 
.PP
\fBReturns:\fP
.RS 4
Current FSYNC interrupt mode (0=active-high, 1=active-low) 
.RE
.PP
\fBSee also:\fP
.RS 4
getFSyncInterruptMode() 
.PP
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT 
.RE
.PP

.SS "uint8_t MPU6050::getFullScaleAccelRange ()"
Get full-scale accelerometer range\&. The FS_SEL parameter allows setting the full-scale range of the accelerometer sensors, as described in the table below\&.
.PP
.PP
.nf

0 = +/- 2g
1 = +/- 4g
2 = +/- 8g
3 = +/- 16g
.fi
.PP
.PP
\fBReturns:\fP
.RS 4
Current full-scale accelerometer range setting 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_ACCEL_FS_2 
.PP
MPU6050_RA_ACCEL_CONFIG 
.PP
MPU6050_ACONFIG_AFS_SEL_BIT 
.PP
MPU6050_ACONFIG_AFS_SEL_LENGTH 
.RE
.PP

.SS "uint8_t MPU6050::getFullScaleGyroRange ()"
Get full-scale gyroscope range\&. The FS_SEL parameter allows setting the full-scale range of the gyro sensors, as described in the table below\&.
.PP
.PP
.nf

0 = +/- 250 degrees/sec
1 = +/- 500 degrees/sec
2 = +/- 1000 degrees/sec
3 = +/- 2000 degrees/sec
.fi
.PP
.PP
\fBReturns:\fP
.RS 4
Current full-scale gyroscope range setting 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_GYRO_FS_250 
.PP
MPU6050_RA_GYRO_CONFIG 
.PP
MPU6050_GCONFIG_FS_SEL_BIT 
.PP
MPU6050_GCONFIG_FS_SEL_LENGTH 
.RE
.PP

.SS "bool MPU6050::getI2CBypassEnabled ()"
Get I2C bypass enabled status\&. When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application processor will be able to directly access the auxiliary I2C bus of the MPU-60X0\&. When this bit is equal to 0, the host application processor will not be able to directly access the auxiliary I2C bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106 bit[5])\&. 
.PP
\fBReturns:\fP
.RS 4
Current I2C bypass enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_I2C_BYPASS_EN_BIT 
.RE
.PP

.SS "bool MPU6050::getI2CMasterModeEnabled ()"
Get I2C Master Mode enabled status\&. When this mode is enabled, the MPU-60X0 acts as the I2C Master to the external sensor slave devices on the auxiliary I2C bus\&. When this bit is cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_CL) are logically driven by the primary I2C bus (SDA and SCL)\&. This is a precondition to enabling Bypass Mode\&. For further information regarding Bypass Mode, please refer to Register 55\&. 
.PP
\fBReturns:\fP
.RS 4
Current I2C Master Mode enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_USER_CTRL 
.PP
MPU6050_USERCTRL_I2C_MST_EN_BIT 
.RE
.PP

.SS "bool MPU6050::getIntDataReadyEnabled ()"
Get Data Ready interrupt enabled setting\&. This event occurs each time a write operation to all of the sensor registers has been completed\&. Will be set 0 for disabled, 1 for enabled\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_DATA_RDY_BIT 
.RE
.PP

.SS "bool MPU6050::getIntDataReadyStatus ()"
Get Data Ready interrupt status\&. This bit automatically sets to 1 when a Data Ready interrupt has been generated\&. The bit clears to 0 after the register has been read\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_STATUS 
.PP
MPU6050_INTERRUPT_DATA_RDY_BIT 
.RE
.PP

.SS "uint8_t MPU6050::getIntEnabled ()"
Get full interrupt enabled status\&. Full register byte for all interrupts, for quick reading\&. Each bit will be set 0 for disabled, 1 for enabled\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_FF_BIT 
.RE
.PP

.SS "bool MPU6050::getInterruptDrive ()"
Get interrupt drive mode\&. Will be set 0 for push-pull, 1 for open-drain\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt drive mode (0=push-pull, 1=open-drain) 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_INT_OPEN_BIT 
.RE
.PP

.SS "bool MPU6050::getInterruptLatch ()"
Get interrupt latch mode\&. Will be set 0 for 50us-pulse, 1 for latch-until-int-cleared\&. 
.PP
\fBReturns:\fP
.RS 4
Current latch mode (0=50us-pulse, 1=latch-until-int-cleared) 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_LATCH_INT_EN_BIT 
.RE
.PP

.SS "bool MPU6050::getInterruptLatchClear ()"
Get interrupt latch clear mode\&. Will be set 0 for status-read-only, 1 for any-register-read\&. 
.PP
\fBReturns:\fP
.RS 4
Current latch clear mode (0=status-read-only, 1=any-register-read) 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_INT_RD_CLEAR_BIT 
.RE
.PP

.SS "bool MPU6050::getInterruptMode ()"
Get interrupt logic level mode\&. Will be set 0 for active-high, 1 for active-low\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt mode (0=active-high, 1=active-low) 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_INT_LEVEL_BIT 
.RE
.PP

.SS "bool MPU6050::getIntFIFOBufferOverflowEnabled ()"
Get FIFO Buffer Overflow interrupt enabled status\&. Will be set 0 for disabled, 1 for enabled\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_FIFO_OFLOW_BIT 
.RE
.PP

.SS "bool MPU6050::getIntFIFOBufferOverflowStatus ()"
Get FIFO Buffer Overflow interrupt status\&. This bit automatically sets to 1 when a Free Fall interrupt has been generated\&. The bit clears to 0 after the register has been read\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_STATUS 
.PP
MPU6050_INTERRUPT_FIFO_OFLOW_BIT 
.RE
.PP

.SS "bool MPU6050::getIntFreefallEnabled ()"
Get Free Fall interrupt enabled status\&. Will be set 0 for disabled, 1 for enabled\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_FF_BIT 
.RE
.PP

.SS "bool MPU6050::getIntFreefallStatus ()"
Get Free Fall interrupt status\&. This bit automatically sets to 1 when a Free Fall interrupt has been generated\&. The bit clears to 0 after the register has been read\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_STATUS 
.PP
MPU6050_INTERRUPT_FF_BIT 
.RE
.PP

.SS "bool MPU6050::getIntI2CMasterEnabled ()"
Get I2C Master interrupt enabled status\&. This enables any of the I2C Master interrupt sources to generate an interrupt\&. Will be set 0 for disabled, 1 for enabled\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_I2C_MST_INT_BIT 
.RE
.PP

.SS "bool MPU6050::getIntI2CMasterStatus ()"
Get I2C Master interrupt status\&. This bit automatically sets to 1 when an I2C Master interrupt has been generated\&. For a list of I2C Master interrupts, please refer to Register 54\&. The bit clears to 0 after the register has been read\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_STATUS 
.PP
MPU6050_INTERRUPT_I2C_MST_INT_BIT 
.RE
.PP

.SS "bool MPU6050::getIntMotionEnabled ()"
Get Motion Detection interrupt enabled status\&. Will be set 0 for disabled, 1 for enabled\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_MOT_BIT 
.RE
.PP

.SS "bool MPU6050::getIntMotionStatus ()"
Get Motion Detection interrupt status\&. This bit automatically sets to 1 when a Motion Detection interrupt has been generated\&. The bit clears to 0 after the register has been read\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_STATUS 
.PP
MPU6050_INTERRUPT_MOT_BIT 
.RE
.PP

.SS "uint8_t MPU6050::getIntStatus ()"
Get full set of interrupt status bits\&. These bits clear to 0 after the register has been read\&. Very useful for getting multiple INT statuses, since each single bit read clears all of them because it has to read the whole byte\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_STATUS 
.RE
.PP

.SS "bool MPU6050::getIntZeroMotionEnabled ()"
Get Zero Motion Detection interrupt enabled status\&. Will be set 0 for disabled, 1 for enabled\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_ZMOT_BIT 
.RE
.PP

.SS "bool MPU6050::getIntZeroMotionStatus ()"
Get Zero Motion Detection interrupt status\&. This bit automatically sets to 1 when a Zero Motion Detection interrupt has been generated\&. The bit clears to 0 after the register has been read\&. 
.PP
\fBReturns:\fP
.RS 4
Current interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_STATUS 
.PP
MPU6050_INTERRUPT_ZMOT_BIT 
.RE
.PP

.SS "bool MPU6050::getLostArbitration ()"
Get master arbitration lost status\&. This bit automatically sets to 1 when the I2C Master has lost arbitration of the auxiliary I2C bus (an error condition)\&. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted\&. 
.PP
\fBReturns:\fP
.RS 4
Master arbitration lost status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_STATUS 
.RE
.PP

.SS "uint8_t MPU6050::getMasterClockSpeed ()"
Get I2C master clock speed\&. I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock\&. It sets the I2C master clock speed according to the following table:
.PP
.PP
.nf

I2C_MST_CLK | I2C Master Clock Speed | 8MHz Clock Divider
------------+------------------------+-------------------
0           | 348kHz                 | 23
1           | 333kHz                 | 24
2           | 320kHz                 | 25
3           | 308kHz                 | 26
4           | 296kHz                 | 27
5           | 286kHz                 | 28
6           | 276kHz                 | 29
7           | 267kHz                 | 30
8           | 258kHz                 | 31
9           | 500kHz                 | 16
10          | 471kHz                 | 17
11          | 444kHz                 | 18
12          | 421kHz                 | 19
13          | 400kHz                 | 20
14          | 381kHz                 | 21
15          | 364kHz                 | 22
.fi
.PP
.PP
\fBReturns:\fP
.RS 4
Current I2C master clock speed 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_CTRL 
.RE
.PP

.SS "void MPU6050::getMotion6 (int16_t *ax, int16_t *ay, int16_t *az, int16_t *gx, int16_t *gy, int16_t *gz)"
Get raw 6-axis motion sensor readings (accel/gyro)\&. Retrieves all currently available motion sensor values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIax\fP 16-bit signed integer container for accelerometer X-axis value 
.br
\fIay\fP 16-bit signed integer container for accelerometer Y-axis value 
.br
\fIaz\fP 16-bit signed integer container for accelerometer Z-axis value 
.br
\fIgx\fP 16-bit signed integer container for gyroscope X-axis value 
.br
\fIgy\fP 16-bit signed integer container for gyroscope Y-axis value 
.br
\fIgz\fP 16-bit signed integer container for gyroscope Z-axis value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetAcceleration()\fP 
.PP
\fBgetRotation()\fP 
.PP
MPU6050_RA_ACCEL_XOUT_H 
.RE
.PP

.SS "void MPU6050::getMotion9 (int16_t *ax, int16_t *ay, int16_t *az, int16_t *gx, int16_t *gy, int16_t *gz, int16_t *mx, int16_t *my, int16_t *mz)"
Get raw 9-axis motion sensor readings (accel/gyro/compass)\&. FUNCTION NOT FULLY IMPLEMENTED YET\&. 
.PP
\fBParameters:\fP
.RS 4
\fIax\fP 16-bit signed integer container for accelerometer X-axis value 
.br
\fIay\fP 16-bit signed integer container for accelerometer Y-axis value 
.br
\fIaz\fP 16-bit signed integer container for accelerometer Z-axis value 
.br
\fIgx\fP 16-bit signed integer container for gyroscope X-axis value 
.br
\fIgy\fP 16-bit signed integer container for gyroscope Y-axis value 
.br
\fIgz\fP 16-bit signed integer container for gyroscope Z-axis value 
.br
\fImx\fP 16-bit signed integer container for magnetometer X-axis value 
.br
\fImy\fP 16-bit signed integer container for magnetometer Y-axis value 
.br
\fImz\fP 16-bit signed integer container for magnetometer Z-axis value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetMotion6()\fP 
.PP
\fBgetAcceleration()\fP 
.PP
\fBgetRotation()\fP 
.PP
MPU6050_RA_ACCEL_XOUT_H 
.RE
.PP

.SS "uint8_t MPU6050::getMotionDetectionCounterDecrement ()"
Get Motion detection counter decrement configuration\&. Detection is registered by the Motion detection module after accelerometer measurements meet their respective threshold conditions over a specified number of samples\&. When the threshold conditions are met, the corresponding detection counter increments by 1\&. The user may control the rate at which the detection counter decrements when the threshold condition is not met by configuring MOT_COUNT\&. The decrement rate can be set according to the following table:
.PP
.PP
.nf

MOT_COUNT | Counter Decrement
----------+------------------
0         | Reset
1         | 1
2         | 2
3         | 4
.fi
.PP
.PP
When MOT_COUNT is configured to 0 (reset), any non-qualifying sample will reset the counter to 0\&. For further information on Motion detection, please refer to Registers 29 to 32\&. 
.SS "uint8_t MPU6050::getMotionDetectionDuration ()"
Get motion detection event duration threshold\&. This register configures the duration counter threshold for Motion interrupt generation\&. The duration counter ticks at 1 kHz, therefore MOT_DUR has a unit of 1LSB = 1ms\&. The Motion detection duration counter increments when the absolute value of any of the accelerometer measurements exceeds the Motion detection threshold (Register 31)\&. The Motion detection interrupt is triggered when the Motion detection counter reaches the time count specified in this register\&.
.PP
For more details on the Motion detection interrupt, see Section 8\&.3 of the MPU-6000/MPU-6050 Product Specification document\&.
.PP
\fBReturns:\fP
.RS 4
Current motion detection duration threshold value (LSB = 1ms) 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_MOT_DUR 
.RE
.PP

.SS "uint8_t MPU6050::getMotionDetectionThreshold ()"
Get motion detection event acceleration threshold\&. This register configures the detection threshold for Motion interrupt generation\&. The unit of MOT_THR is 1LSB = 2mg\&. Motion is detected when the absolute value of any of the accelerometer measurements exceeds this Motion detection threshold\&. This condition increments the Motion detection duration counter (Register 32)\&. The Motion detection interrupt is triggered when the Motion Detection counter reaches the time count specified in MOT_DUR (Register 32)\&.
.PP
The Motion interrupt will indicate the axis and polarity of detected motion in MOT_DETECT_STATUS (Register 97)\&.
.PP
For more details on the Motion detection interrupt, see Section 8\&.3 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document\&.
.PP
\fBReturns:\fP
.RS 4
Current motion detection acceleration threshold value (LSB = 2mg) 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_MOT_THR 
.RE
.PP

.SS "bool MPU6050::getMultiMasterEnabled ()"
Get multi-master enabled value\&. Multi-master capability allows multiple I2C masters to operate on the same bus\&. In circuits where multi-master capability is required, set MULT_MST_EN to 1\&. This will increase current drawn by approximately 30uA\&.
.PP
In circuits where multi-master capability is required, the state of the I2C bus must always be monitored by each separate I2C Master\&. Before an I2C Master can assume arbitration of the bus, it must first confirm that no other I2C Master has arbitration of the bus\&. When MULT_MST_EN is set to 1, the MPU-60X0's bus arbitration detection logic is turned on, enabling it to detect when the bus is available\&.
.PP
\fBReturns:\fP
.RS 4
Current multi-master enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_CTRL 
.RE
.PP

.SS "bool MPU6050::getPassthroughStatus ()"
Get FSYNC interrupt status\&. This bit reflects the status of the FSYNC interrupt from an external device into the MPU-60X0\&. This is used as a way to pass an external interrupt through the MPU-60X0 to the host application processor\&. When set to 1, this bit will cause an interrupt if FSYNC_INT_EN is asserted in INT_PIN_CFG (Register 55)\&. 
.PP
\fBReturns:\fP
.RS 4
FSYNC interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_STATUS 
.RE
.PP

.SS "uint8_t MPU6050::getRate ()"
Get gyroscope output rate divider\&. The sensor register output, FIFO output, DMP sampling, Motion detection, Zero Motion detection, and Free Fall detection are all based on the Sample Rate\&. The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:
.PP
Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
.PP
where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled (see Register 26)\&.
.PP
Note: The accelerometer output rate is 1kHz\&. This means that for a Sample Rate greater than 1kHz, the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once\&.
.PP
For a diagram of the gyroscope and accelerometer signal paths, see Section 8 of the MPU-6000/MPU-6050 Product Specification document\&.
.PP
\fBReturns:\fP
.RS 4
Current sample rate 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_SMPLRT_DIV 
.RE
.PP

.SS "void MPU6050::getRotation (int16_t *x, int16_t *y, int16_t *z)"
Get 3-axis gyroscope readings\&. These gyroscope measurement registers, along with the accelerometer measurement registers, temperature measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set\&. The data within the gyroscope sensors' internal register set is always updated at the Sample Rate\&. Meanwhile, the user-facing read register set duplicates the internal register set's data values whenever the serial interface is idle\&. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant\&. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt\&.
.PP
Each 16-bit gyroscope measurement has a full scale defined in FS_SEL (Register 27)\&. For each full scale setting, the gyroscopes' sensitivity per LSB in GYRO_xOUT is shown in the table below:
.PP
.PP
.nf

FS_SEL | Full Scale Range   | LSB Sensitivity
-------+--------------------+----------------
0      | +/- 250 degrees/s  | 131 LSB/deg/s
1      | +/- 500 degrees/s  | 65\&.5 LSB/deg/s
2      | +/- 1000 degrees/s | 32\&.8 LSB/deg/s
3      | +/- 2000 degrees/s | 16\&.4 LSB/deg/s
.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fIx\fP 16-bit signed integer container for X-axis rotation 
.br
\fIy\fP 16-bit signed integer container for Y-axis rotation 
.br
\fIz\fP 16-bit signed integer container for Z-axis rotation 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetMotion6()\fP 
.PP
MPU6050_RA_GYRO_XOUT_H 
.RE
.PP

.SS "int16_t MPU6050::getRotationX ()"
Get X-axis gyroscope reading\&. 
.PP
\fBReturns:\fP
.RS 4
X-axis rotation measurement in 16-bit 2's complement format 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetMotion6()\fP 
.PP
MPU6050_RA_GYRO_XOUT_H 
.RE
.PP

.SS "int16_t MPU6050::getRotationY ()"
Get Y-axis gyroscope reading\&. 
.PP
\fBReturns:\fP
.RS 4
Y-axis rotation measurement in 16-bit 2's complement format 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetMotion6()\fP 
.PP
MPU6050_RA_GYRO_YOUT_H 
.RE
.PP

.SS "int16_t MPU6050::getRotationZ ()"
Get Z-axis gyroscope reading\&. 
.PP
\fBReturns:\fP
.RS 4
Z-axis rotation measurement in 16-bit 2's complement format 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetMotion6()\fP 
.PP
MPU6050_RA_GYRO_ZOUT_H 
.RE
.PP

.SS "uint8_t MPU6050::getSlate4InputByte ()"
Get last available byte read from Slave 4\&. This register stores the data read from Slave 4\&. This field is populated after a read transaction\&. 
.PP
\fBReturns:\fP
.RS 4
Last available byte read from to Slave 4 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV4_DI 
.RE
.PP

.SS "bool MPU6050::getSlave0FIFOEnabled ()"
Get Slave 0 FIFO enabled value\&. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 0 to be written into the FIFO buffer\&. 
.PP
\fBReturns:\fP
.RS 4
Current Slave 0 FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "bool MPU6050::getSlave0Nack ()"
Get Slave 0 NACK status\&. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 0\&. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted\&. 
.PP
\fBReturns:\fP
.RS 4
Slave 0 NACK interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_STATUS 
.RE
.PP

.SS "bool MPU6050::getSlave1FIFOEnabled ()"
Get Slave 1 FIFO enabled value\&. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 1 to be written into the FIFO buffer\&. 
.PP
\fBReturns:\fP
.RS 4
Current Slave 1 FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "bool MPU6050::getSlave1Nack ()"
Get Slave 1 NACK status\&. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 1\&. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted\&. 
.PP
\fBReturns:\fP
.RS 4
Slave 1 NACK interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_STATUS 
.RE
.PP

.SS "bool MPU6050::getSlave2FIFOEnabled ()"
Get Slave 2 FIFO enabled value\&. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 2 to be written into the FIFO buffer\&. 
.PP
\fBReturns:\fP
.RS 4
Current Slave 2 FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "bool MPU6050::getSlave2Nack ()"
Get Slave 2 NACK status\&. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 2\&. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted\&. 
.PP
\fBReturns:\fP
.RS 4
Slave 2 NACK interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_STATUS 
.RE
.PP

.SS "bool MPU6050::getSlave3FIFOEnabled ()"
Get Slave 3 FIFO enabled value\&. When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 3 to be written into the FIFO buffer\&. 
.PP
\fBReturns:\fP
.RS 4
Current Slave 3 FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_MST_CTRL 
.RE
.PP

.SS "bool MPU6050::getSlave3Nack ()"
Get Slave 3 NACK status\&. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 3\&. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted\&. 
.PP
\fBReturns:\fP
.RS 4
Slave 3 NACK interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_STATUS 
.RE
.PP

.SS "uint8_t MPU6050::getSlave4Address ()"
Get the I2C address of Slave 4\&. Note that Bit 7 (MSB) controls read/write mode\&. If Bit 7 is set, it's a read operation, and if it is cleared, then it's a write operation\&. The remaining bits (6-0) are the 7-bit device address of the slave device\&.
.PP
\fBReturns:\fP
.RS 4
Current address for Slave 4 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlaveAddress()\fP 
.PP
MPU6050_RA_I2C_SLV4_ADDR 
.RE
.PP

.SS "bool MPU6050::getSlave4Enabled ()"
Get the enabled value for the Slave 4\&. When set to 1, this bit enables Slave 4 for data transfer operations\&. When cleared to 0, this bit disables Slave 4 from data transfer operations\&. 
.PP
\fBReturns:\fP
.RS 4
Current enabled value for Slave 4 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV4_CTRL 
.RE
.PP

.SS "bool MPU6050::getSlave4InterruptEnabled ()"
Get the enabled value for Slave 4 transaction interrupts\&. When set to 1, this bit enables the generation of an interrupt signal upon completion of a Slave 4 transaction\&. When cleared to 0, this bit disables the generation of an interrupt signal upon completion of a Slave 4 transaction\&. The interrupt status can be observed in Register 54\&.
.PP
\fBReturns:\fP
.RS 4
Current enabled value for Slave 4 transaction interrupts\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV4_CTRL 
.RE
.PP

.SS "bool MPU6050::getSlave4IsDone ()"
Get Slave 4 transaction done status\&. Automatically sets to 1 when a Slave 4 transaction has completed\&. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted and if the SLV_4_DONE_INT bit is asserted in the I2C_SLV4_CTRL register (Register 52)\&. 
.PP
\fBReturns:\fP
.RS 4
Slave 4 transaction done status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_STATUS 
.RE
.PP

.SS "uint8_t MPU6050::getSlave4MasterDelay ()"
Get Slave 4 master delay value\&. This configures the reduced access rate of I2C slaves relative to the Sample Rate\&. When a slave's access rate is decreased relative to the Sample Rate, the slave is accessed every: 
.PP
.nf
1 / (1 + I2C_MST_DLY) samples

.fi
.PP
.PP
This base Sample Rate in turn is determined by SMPLRT_DIV (register 25) and DLPF_CFG (register 26)\&. Whether a slave's access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (register 103)\&. For further information regarding the Sample Rate, please refer to register 25\&.
.PP
\fBReturns:\fP
.RS 4
Current Slave 4 master delay value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV4_CTRL 
.RE
.PP

.SS "bool MPU6050::getSlave4Nack ()"
Get Slave 4 NACK status\&. This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 4\&. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted\&. 
.PP
\fBReturns:\fP
.RS 4
Slave 4 NACK interrupt status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_STATUS 
.RE
.PP

.SS "uint8_t MPU6050::getSlave4Register ()"
Get the active internal register for the Slave 4\&. Read/write operations for this slave will be done to whatever internal register address is stored in this MPU register\&.
.PP
\fBReturns:\fP
.RS 4
Current active register for Slave 4 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV4_REG 
.RE
.PP

.SS "bool MPU6050::getSlave4WriteMode ()"
Get write mode for Slave 4\&. When set to 1, the transaction will read or write data only\&. When cleared to 0, the transaction will write a register address prior to reading or writing data\&. This should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place\&.
.PP
\fBReturns:\fP
.RS 4
Current write mode for Slave 4 (0 = register address + data, 1 = data only) 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV4_CTRL 
.RE
.PP

.SS "uint8_t MPU6050::getSlaveAddress (uint8_tnum)"
Get the I2C address of the specified slave (0-3)\&. Note that Bit 7 (MSB) controls read/write mode\&. If Bit 7 is set, it's a read operation, and if it is cleared, then it's a write operation\&. The remaining bits (6-0) are the 7-bit device address of the slave device\&.
.PP
In read mode, the result of the read is placed in the lowest available EXT_SENS_DATA register\&. For further information regarding the allocation of read results, please refer to the EXT_SENS_DATA register description (Registers 73 - 96)\&.
.PP
The MPU-6050 supports a total of five slaves, but Slave 4 has unique characteristics, and so it has its own functions (getSlave4* and setSlave4*)\&.
.PP
I2C data transactions are performed at the Sample Rate, as defined in Register 25\&. The user is responsible for ensuring that I2C data transactions to and from each enabled Slave can be completed within a single period of the Sample Rate\&.
.PP
The I2C slave access rate can be reduced relative to the Sample Rate\&. This reduced access rate is determined by I2C_MST_DLY (Register 52)\&. Whether a slave's access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (Register 103)\&.
.PP
The processing order for the slaves is fixed\&. The sequence followed for processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4\&. If a particular Slave is disabled it will be skipped\&.
.PP
Each slave can either be accessed at the sample rate or at a reduced sample rate\&. In a case where some slaves are accessed at the Sample Rate and some slaves are accessed at the reduced rate, the sequence of accessing the slaves (Slave 0 to Slave 4) is still followed\&. However, the reduced rate slaves will be skipped if their access rate dictates that they should not be accessed during that particular cycle\&. For further information regarding the reduced access rate, please refer to Register 52\&. Whether a slave is accessed at the Sample Rate or at the reduced rate is determined by the Delay Enable bits in Register 103\&.
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.RE
.PP
\fBReturns:\fP
.RS 4
Current address for specified slave 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV0_ADDR 
.RE
.PP

.SS "uint8_t MPU6050::getSlaveDataLength (uint8_tnum)"
Get number of bytes to read for the specified slave (0-3)\&. Specifies the number of bytes transferred to and from Slave 0\&. Clearing this bit to 0 is equivalent to disabling the register by writing 0 to I2C_SLV0_EN\&. 
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of bytes to read for specified slave 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV0_CTRL 
.RE
.PP

.SS "bool MPU6050::getSlaveDelayEnabled (uint8_tnum)"
Get slave delay enabled status\&. When a particular slave delay is enabled, the rate of access for the that slave device is reduced\&. When a slave's access rate is decreased relative to the Sample Rate, the slave is accessed every: 
.PP
.nf
1 / (1 + I2C_MST_DLY) Samples

.fi
.PP
.PP
This base Sample Rate in turn is determined by SMPLRT_DIV (register * 25) and DLPF_CFG (register 26)\&.
.PP
For further information regarding I2C_MST_DLY, please refer to register 52\&. For further information regarding the Sample Rate, please refer to register 25\&.
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-4) 
.RE
.PP
\fBReturns:\fP
.RS 4
Current slave delay enabled status\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_DELAY_CTRL 
.PP
MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT 
.RE
.PP

.SS "bool MPU6050::getSlaveEnabled (uint8_tnum)"
Get the enabled value for the specified slave (0-3)\&. When set to 1, this bit enables Slave 0 for data transfer operations\&. When cleared to 0, this bit disables Slave 0 from data transfer operations\&. 
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.RE
.PP
\fBReturns:\fP
.RS 4
Current enabled value for specified slave 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV0_CTRL 
.RE
.PP

.SS "bool MPU6050::getSlaveReadWriteTransitionEnabled ()"
Get slave read/write transition enabled value\&. The I2C_MST_P_NSR bit configures the I2C Master's transition from one slave read to the next slave read\&. If the bit equals 0, there will be a restart between reads\&. If the bit equals 1, there will be a stop followed by a start of the following read\&. When a write transaction follows a read transaction, the stop followed by a start of the successive write will be always used\&.
.PP
\fBReturns:\fP
.RS 4
Current slave read/write transition enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_CTRL 
.RE
.PP

.SS "uint8_t MPU6050::getSlaveRegister (uint8_tnum)"
Get the active internal register for the specified slave (0-3)\&. Read/write operations for this slave will be done to whatever internal register address is stored in this MPU register\&.
.PP
The MPU-6050 supports a total of five slaves, but Slave 4 has unique characteristics, and so it has its own functions\&.
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.RE
.PP
\fBReturns:\fP
.RS 4
Current active register for specified slave 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV0_REG 
.RE
.PP

.SS "bool MPU6050::getSlaveWordByteSwap (uint8_tnum)"
Get word pair byte-swapping enabled for the specified slave (0-3)\&. When set to 1, this bit enables byte swapping\&. When byte swapping is enabled, the high and low bytes of a word pair are swapped\&. Please refer to I2C_SLV0_GRP for the pairing convention of the word pairs\&. When cleared to 0, bytes transferred to and from Slave 0 will be written to EXT_SENS_DATA registers in the order they were transferred\&.
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.RE
.PP
\fBReturns:\fP
.RS 4
Current word pair byte-swapping enabled value for specified slave 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV0_CTRL 
.RE
.PP

.SS "bool MPU6050::getSlaveWordGroupOffset (uint8_tnum)"
Get word pair grouping order offset for the specified slave (0-3)\&. This sets specifies the grouping order of word pairs received from registers\&. When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even, then odd register addresses) are paired to form a word\&. When set to 1, bytes from register addresses are paired 1 and 2, 3 and 4, etc\&. (odd, then even register addresses) are paired to form a word\&.
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.RE
.PP
\fBReturns:\fP
.RS 4
Current word pair grouping order offset for specified slave 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV0_CTRL 
.RE
.PP

.SS "bool MPU6050::getSlaveWriteMode (uint8_tnum)"
Get write mode for the specified slave (0-3)\&. When set to 1, the transaction will read or write data only\&. When cleared to 0, the transaction will write a register address prior to reading or writing data\&. This should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place\&.
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.RE
.PP
\fBReturns:\fP
.RS 4
Current write mode for specified slave (0 = register address + data, 1 = data only) 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV0_CTRL 
.RE
.PP

.SS "bool MPU6050::getSleepEnabled ()"
Get sleep mode status\&. Setting the SLEEP bit in the register puts the device into very low power sleep mode\&. In this mode, only the serial interface and internal registers remain active, allowing for a very low standby current\&. Clearing this bit puts the device back into normal mode\&. To save power, the individual standby selections for each of the gyros should be used if any gyro axis is not used by the application\&. 
.PP
\fBReturns:\fP
.RS 4
Current sleep mode enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_PWR_MGMT_1 
.PP
MPU6050_PWR1_SLEEP_BIT 
.RE
.PP

.SS "int16_t MPU6050::getTemperature ()"
Get current internal temperature\&. 
.PP
\fBReturns:\fP
.RS 4
Temperature reading in 16-bit 2's complement format 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_TEMP_OUT_H 
.RE
.PP

.SS "bool MPU6050::getTempFIFOEnabled ()"
Get temperature FIFO enabled value\&. When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and 66) to be written into the FIFO buffer\&. 
.PP
\fBReturns:\fP
.RS 4
Current temperature FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "bool MPU6050::getTempSensorEnabled ()"
Get temperature sensor enabled status\&. Control the usage of the internal temperature sensor\&.
.PP
Note: this register stores the \fIdisabled\fP value, but for consistency with the rest of the code, the function is named and used with standard true/false values to indicate whether the sensor is enabled or disabled, respectively\&.
.PP
\fBReturns:\fP
.RS 4
Current temperature sensor enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_PWR_MGMT_1 
.PP
MPU6050_PWR1_TEMP_DIS_BIT 
.RE
.PP

.SS "bool MPU6050::getWaitForExternalSensorEnabled ()"
Get wait-for-external-sensor-data enabled value\&. When the WAIT_FOR_ES bit is set to 1, the Data Ready interrupt will be delayed until External Sensor data from the Slave Devices are loaded into the EXT_SENS_DATA registers\&. This is used to ensure that both the internal sensor data (i\&.e\&. from gyro and accel) and external sensor data have been loaded to their respective data registers (i\&.e\&. the data is synced) when the Data Ready interrupt is triggered\&.
.PP
\fBReturns:\fP
.RS 4
Current wait-for-external-sensor-data enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_CTRL 
.RE
.PP

.SS "bool MPU6050::getWakeCycleEnabled ()"
Get wake cycle enabled status\&. When this bit is set to 1 and SLEEP is disabled, the MPU-60X0 will cycle between sleep mode and waking up to take a single sample of data from active sensors at a rate determined by LP_WAKE_CTRL (register 108)\&. 
.PP
\fBReturns:\fP
.RS 4
Current sleep mode enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_PWR_MGMT_1 
.PP
MPU6050_PWR1_CYCLE_BIT 
.RE
.PP

.SS "bool MPU6050::getXGyroFIFOEnabled ()"
Get gyroscope X-axis FIFO enabled value\&. When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_L (Registers 67 and 68) to be written into the FIFO buffer\&. 
.PP
\fBReturns:\fP
.RS 4
Current gyroscope X-axis FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "bool MPU6050::getXNegMotionDetected ()"
Get X-axis negative motion detection interrupt status\&. 
.PP
\fBReturns:\fP
.RS 4
Motion detection status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_MOT_DETECT_STATUS 
.PP
MPU6050_MOTION_MOT_XNEG_BIT 
.RE
.PP

.SS "bool MPU6050::getXPosMotionDetected ()"
Get X-axis positive motion detection interrupt status\&. 
.PP
\fBReturns:\fP
.RS 4
Motion detection status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_MOT_DETECT_STATUS 
.PP
MPU6050_MOTION_MOT_XPOS_BIT 
.RE
.PP

.SS "bool MPU6050::getYGyroFIFOEnabled ()"
Get gyroscope Y-axis FIFO enabled value\&. When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_L (Registers 69 and 70) to be written into the FIFO buffer\&. 
.PP
\fBReturns:\fP
.RS 4
Current gyroscope Y-axis FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "bool MPU6050::getYNegMotionDetected ()"
Get Y-axis negative motion detection interrupt status\&. 
.PP
\fBReturns:\fP
.RS 4
Motion detection status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_MOT_DETECT_STATUS 
.PP
MPU6050_MOTION_MOT_YNEG_BIT 
.RE
.PP

.SS "bool MPU6050::getYPosMotionDetected ()"
Get Y-axis positive motion detection interrupt status\&. 
.PP
\fBReturns:\fP
.RS 4
Motion detection status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_MOT_DETECT_STATUS 
.PP
MPU6050_MOTION_MOT_YPOS_BIT 
.RE
.PP

.SS "bool MPU6050::getZeroMotionDetected ()"
Get zero motion detection interrupt status\&. 
.PP
\fBReturns:\fP
.RS 4
Motion detection status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_MOT_DETECT_STATUS 
.PP
MPU6050_MOTION_MOT_ZRMOT_BIT 
.RE
.PP

.SS "uint8_t MPU6050::getZeroMotionDetectionDuration ()"
Get zero motion detection event duration threshold\&. This register configures the duration counter threshold for Zero Motion interrupt generation\&. The duration counter ticks at 16 Hz, therefore ZRMOT_DUR has a unit of 1 LSB = 64 ms\&. The Zero Motion duration counter increments while the absolute value of the accelerometer measurements are each less than the detection threshold (Register 33)\&. The Zero Motion interrupt is triggered when the Zero Motion duration counter reaches the time count specified in this register\&.
.PP
For more details on the Zero Motion detection interrupt, see Section 8\&.4 of the MPU-6000/MPU-6050 Product Specification document, as well as Registers 56 and 58 of this document\&.
.PP
\fBReturns:\fP
.RS 4
Current zero motion detection duration threshold value (LSB = 64ms) 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_ZRMOT_DUR 
.RE
.PP

.SS "uint8_t MPU6050::getZeroMotionDetectionThreshold ()"
Get zero motion detection event acceleration threshold\&. This register configures the detection threshold for Zero Motion interrupt generation\&. The unit of ZRMOT_THR is 1LSB = 2mg\&. Zero Motion is detected when the absolute value of the accelerometer measurements for the 3 axes are each less than the detection threshold\&. This condition increments the Zero Motion duration counter (Register 34)\&. The Zero Motion interrupt is triggered when the Zero Motion duration counter reaches the time count specified in ZRMOT_DUR (Register 34)\&.
.PP
Unlike Free Fall or Motion detection, Zero Motion detection triggers an interrupt both when Zero Motion is first detected and when Zero Motion is no longer detected\&.
.PP
When a zero motion event is detected, a Zero Motion Status will be indicated in the MOT_DETECT_STATUS register (Register 97)\&. When a motion-to-zero-motion condition is detected, the status bit is set to 1\&. When a zero-motion-to- motion condition is detected, the status bit is set to 0\&.
.PP
For more details on the Zero Motion detection interrupt, see Section 8\&.4 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document\&.
.PP
\fBReturns:\fP
.RS 4
Current zero motion detection acceleration threshold value (LSB = 2mg) 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_ZRMOT_THR 
.RE
.PP

.SS "bool MPU6050::getZGyroFIFOEnabled ()"
Get gyroscope Z-axis FIFO enabled value\&. When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_L (Registers 71 and 72) to be written into the FIFO buffer\&. 
.PP
\fBReturns:\fP
.RS 4
Current gyroscope Z-axis FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "bool MPU6050::getZNegMotionDetected ()"
Get Z-axis negative motion detection interrupt status\&. 
.PP
\fBReturns:\fP
.RS 4
Motion detection status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_MOT_DETECT_STATUS 
.PP
MPU6050_MOTION_MOT_ZNEG_BIT 
.RE
.PP

.SS "bool MPU6050::getZPosMotionDetected ()"
Get Z-axis positive motion detection interrupt status\&. 
.PP
\fBReturns:\fP
.RS 4
Motion detection status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_MOT_DETECT_STATUS 
.PP
MPU6050_MOTION_MOT_ZPOS_BIT 
.RE
.PP

.SS "void MPU6050::initialize ()"
Power on and prepare for general usage\&. This will activate the device and take it out of sleep mode (which must be done after start-up)\&. This function also sets both the accelerometer and the gyroscope to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets the clock source to use the X Gyro for reference, which is slightly better than the default internal clock source\&. 
.SS "void MPU6050::reset ()"
Trigger a full device reset\&. A small delay of ~50ms may be desirable after triggering a reset\&. 
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_PWR_MGMT_1 
.PP
MPU6050_PWR1_DEVICE_RESET_BIT 
.RE
.PP

.SS "void MPU6050::resetAccelerometerPath ()"
Reset accelerometer signal path\&. The reset will revert the signal path analog to digital converters and filters to their power up configurations\&. 
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_SIGNAL_PATH_RESET 
.PP
MPU6050_PATHRESET_ACCEL_RESET_BIT 
.RE
.PP

.SS "void MPU6050::resetFIFO ()"
Reset the FIFO\&. This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0\&. This bit automatically clears to 0 after the reset has been triggered\&. 
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_USER_CTRL 
.PP
MPU6050_USERCTRL_FIFO_RESET_BIT 
.RE
.PP

.SS "void MPU6050::resetGyroscopePath ()"
Reset gyroscope signal path\&. The reset will revert the signal path analog to digital converters and filters to their power up configurations\&. 
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_SIGNAL_PATH_RESET 
.PP
MPU6050_PATHRESET_GYRO_RESET_BIT 
.RE
.PP

.SS "void MPU6050::resetI2CMaster ()"
Reset the I2C Master\&. This bit resets the I2C Master when set to 1 while I2C_MST_EN equals 0\&. This bit automatically clears to 0 after the reset has been triggered\&. 
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_USER_CTRL 
.PP
MPU6050_USERCTRL_I2C_MST_RESET_BIT 
.RE
.PP

.SS "void MPU6050::resetSensors ()"
Reset all sensor registers and signal paths\&. When set to 1, this bit resets the signal paths for all sensors (gyroscopes, accelerometers, and temperature sensor)\&. This operation will also clear the sensor registers\&. This bit automatically clears to 0 after the reset has been triggered\&.
.PP
When resetting only the signal path (and not the sensor registers), please use Register 104, SIGNAL_PATH_RESET\&.
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_USER_CTRL 
.PP
MPU6050_USERCTRL_SIG_COND_RESET_BIT 
.RE
.PP

.SS "void MPU6050::resetTemperaturePath ()"
Reset temperature sensor signal path\&. The reset will revert the signal path analog to digital converters and filters to their power up configurations\&. 
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_SIGNAL_PATH_RESET 
.PP
MPU6050_PATHRESET_TEMP_RESET_BIT 
.RE
.PP

.SS "void MPU6050::setAccelerometerPowerOnDelay (uint8_tdelay)"
Set accelerometer power-on delay\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdelay\fP New accelerometer power-on delay (0-3) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetAccelerometerPowerOnDelay()\fP 
.PP
MPU6050_RA_MOT_DETECT_CTRL 
.PP
MPU6050_DETECT_ACCEL_ON_DELAY_BIT 
.RE
.PP

.SS "void MPU6050::setAccelFIFOEnabled (boolenabled)"
Set accelerometer FIFO enabled value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New accelerometer FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetAccelFIFOEnabled()\fP 
.PP
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "void MPU6050::setAccelXSelfTest (boolenabled)"
Get self-test enabled setting for accelerometer X axis\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP Self-test enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_ACCEL_CONFIG 
.RE
.PP

.SS "void MPU6050::setAccelYSelfTest (boolenabled)"
Get self-test enabled value for accelerometer Y axis\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP Self-test enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_ACCEL_CONFIG 
.RE
.PP

.SS "void MPU6050::setAccelZSelfTest (boolenabled)"
Set self-test enabled value for accelerometer Z axis\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP Self-test enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_ACCEL_CONFIG 
.RE
.PP

.SS "void MPU6050::setAuxVDDIOLevel (uint8_tlevel)"
Set the auxiliary I2C supply voltage level\&. When set to 1, the auxiliary I2C bus high logic level is VDD\&. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC\&. This does not apply to the MPU-6000, which does not have a VLOGIC pin\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlevel\fP I2C supply voltage level (0=VLOGIC, 1=VDD) 
.RE
.PP

.SS "void MPU6050::setClockOutputEnabled (boolenabled)"
Set reference clock output enabled status\&. When this bit is equal to 1, a reference clock output is provided at the CLKOUT pin\&. When this bit is equal to 0, the clock output is disabled\&. For further information regarding CLKOUT, please refer to the MPU-60X0 Product Specification document\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New reference clock output enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_CLKOUT_EN_BIT 
.RE
.PP

.SS "void MPU6050::setClockSource (uint8_tsource)"
Set clock source setting\&. An internal 8MHz oscillator, gyroscope based clock, or external sources can be selected as the MPU-60X0 clock source\&. When the internal 8 MHz oscillator or an external source is chosen as the clock source, the MPU-60X0 can operate in low power modes with the gyroscopes disabled\&.
.PP
Upon power up, the MPU-60X0 clock source defaults to the internal oscillator\&. However, it is highly recommended that the device be configured to use one of the gyroscopes (or an external clock source) as the clock reference for improved stability\&. The clock source can be selected according to the following table:
.PP
.PP
.nf

CLK_SEL | Clock Source
--------+--------------------------------------
0       | Internal oscillator
1       | PLL with X Gyro reference
2       | PLL with Y Gyro reference
3       | PLL with Z Gyro reference
4       | PLL with external 32\&.768kHz reference
5       | PLL with external 19\&.2MHz reference
6       | Reserved
7       | Stops the clock and keeps the timing generator in reset
.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP New clock source setting 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetClockSource()\fP 
.PP
MPU6050_RA_PWR_MGMT_1 
.PP
MPU6050_PWR1_CLKSEL_BIT 
.PP
MPU6050_PWR1_CLKSEL_LENGTH 
.RE
.PP

.SS "void MPU6050::setDHPFMode (uint8_tbandwidth)"
Set the high-pass filter configuration\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbandwidth\fP New high-pass filter configuration 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBsetDHPFMode()\fP 
.PP
MPU6050_DHPF_RESET 
.PP
MPU6050_RA_ACCEL_CONFIG 
.RE
.PP

.SS "void MPU6050::setDLPFMode (uint8_tmode)"
Set digital low-pass filter configuration\&. 
.PP
\fBParameters:\fP
.RS 4
\fImode\fP New DLFP configuration setting 
.RE
.PP
\fBSee also:\fP
.RS 4
getDLPFBandwidth() 
.PP
MPU6050_DLPF_BW_256 
.PP
MPU6050_RA_CONFIG 
.PP
MPU6050_CFG_DLPF_CFG_BIT 
.PP
MPU6050_CFG_DLPF_CFG_LENGTH 
.RE
.PP

.SS "void MPU6050::setExternalFrameSync (uint8_tsync)"
Set external FSYNC configuration\&. 
.PP
\fBSee also:\fP
.RS 4
\fBgetExternalFrameSync()\fP 
.PP
MPU6050_RA_CONFIG 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsync\fP New FSYNC configuration value 
.RE
.PP

.SS "void MPU6050::setExternalShadowDelayEnabled (boolenabled)"
Set external data shadow delay enabled status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New external data shadow delay enabled status\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetExternalShadowDelayEnabled()\fP 
.PP
MPU6050_RA_I2C_MST_DELAY_CTRL 
.PP
MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT 
.RE
.PP

.SS "void MPU6050::setFIFOEnabled (boolenabled)"
Set FIFO enabled status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New FIFO enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetFIFOEnabled()\fP 
.PP
MPU6050_RA_USER_CTRL 
.PP
MPU6050_USERCTRL_FIFO_EN_BIT 
.RE
.PP

.SS "void MPU6050::setFreefallDetectionCounterDecrement (uint8_tdecrement)"
Set Free Fall detection counter decrement configuration\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdecrement\fP New decrement configuration value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetFreefallDetectionCounterDecrement()\fP 
.PP
MPU6050_RA_MOT_DETECT_CTRL 
.PP
MPU6050_DETECT_FF_COUNT_BIT 
.RE
.PP

.SS "void MPU6050::setFreefallDetectionDuration (uint8_tduration)"
Get free-fall event duration threshold\&. 
.PP
\fBParameters:\fP
.RS 4
\fIduration\fP New free-fall duration threshold value (LSB = 1ms) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetFreefallDetectionDuration()\fP 
.PP
MPU6050_RA_FF_DUR 
.RE
.PP

.SS "void MPU6050::setFreefallDetectionThreshold (uint8_tthreshold)"
Get free-fall event acceleration threshold\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthreshold\fP New free-fall acceleration threshold value (LSB = 2mg) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetFreefallDetectionThreshold()\fP 
.PP
MPU6050_RA_FF_THR 
.RE
.PP

.SS "void MPU6050::setFSyncInterruptEnabled (boolenabled)"
Set FSYNC pin interrupt enabled setting\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New FSYNC pin interrupt enabled setting 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetFSyncInterruptEnabled()\fP 
.PP
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_FSYNC_INT_EN_BIT 
.RE
.PP

.SS "void MPU6050::setFSyncInterruptLevel (boollevel)"
Set FSYNC interrupt logic level mode\&. 
.PP
\fBParameters:\fP
.RS 4
\fImode\fP New FSYNC interrupt mode (0=active-high, 1=active-low) 
.RE
.PP
\fBSee also:\fP
.RS 4
getFSyncInterruptMode() 
.PP
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT 
.RE
.PP

.SS "void MPU6050::setFullScaleAccelRange (uint8_trange)"
Set full-scale accelerometer range\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrange\fP New full-scale accelerometer range setting 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetFullScaleAccelRange()\fP 
.RE
.PP

.SS "void MPU6050::setFullScaleGyroRange (uint8_trange)"
Set full-scale gyroscope range\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrange\fP New full-scale gyroscope range value 
.RE
.PP
\fBSee also:\fP
.RS 4
getFullScaleRange() 
.PP
MPU6050_GYRO_FS_250 
.PP
MPU6050_RA_GYRO_CONFIG 
.PP
MPU6050_GCONFIG_FS_SEL_BIT 
.PP
MPU6050_GCONFIG_FS_SEL_LENGTH 
.RE
.PP

.SS "void MPU6050::setI2CBypassEnabled (boolenabled)"
Set I2C bypass enabled status\&. When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application processor will be able to directly access the auxiliary I2C bus of the MPU-60X0\&. When this bit is equal to 0, the host application processor will not be able to directly access the auxiliary I2C bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106 bit[5])\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New I2C bypass enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_I2C_BYPASS_EN_BIT 
.RE
.PP

.SS "void MPU6050::setI2CMasterModeEnabled (boolenabled)"
Set I2C Master Mode enabled status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New I2C Master Mode enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetI2CMasterModeEnabled()\fP 
.PP
MPU6050_RA_USER_CTRL 
.PP
MPU6050_USERCTRL_I2C_MST_EN_BIT 
.RE
.PP

.SS "void MPU6050::setIntDataReadyEnabled (boolenabled)"
Set Data Ready interrupt enabled status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetIntDataReadyEnabled()\fP 
.PP
MPU6050_RA_INT_CFG 
.PP
MPU6050_INTERRUPT_DATA_RDY_BIT 
.RE
.PP

.SS "void MPU6050::setIntEnabled (uint8_tenabled)"
Set full interrupt enabled status\&. Full register byte for all interrupts, for quick reading\&. Each bit should be set 0 for disabled, 1 for enabled\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetIntFreefallEnabled()\fP 
.PP
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_FF_BIT 
.RE
.PP

.SS "void MPU6050::setInterruptDrive (booldrive)"
Set interrupt drive mode\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdrive\fP New interrupt drive mode (0=push-pull, 1=open-drain) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetInterruptDrive()\fP 
.PP
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_INT_OPEN_BIT 
.RE
.PP

.SS "void MPU6050::setInterruptLatch (boollatch)"
Set interrupt latch mode\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlatch\fP New latch mode (0=50us-pulse, 1=latch-until-int-cleared) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetInterruptLatch()\fP 
.PP
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_LATCH_INT_EN_BIT 
.RE
.PP

.SS "void MPU6050::setInterruptLatchClear (boolclear)"
Set interrupt latch clear mode\&. 
.PP
\fBParameters:\fP
.RS 4
\fIclear\fP New latch clear mode (0=status-read-only, 1=any-register-read) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetInterruptLatchClear()\fP 
.PP
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_INT_RD_CLEAR_BIT 
.RE
.PP

.SS "void MPU6050::setInterruptMode (boolmode)"
Set interrupt logic level mode\&. 
.PP
\fBParameters:\fP
.RS 4
\fImode\fP New interrupt mode (0=active-high, 1=active-low) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetInterruptMode()\fP 
.PP
MPU6050_RA_INT_PIN_CFG 
.PP
MPU6050_INTCFG_INT_LEVEL_BIT 
.RE
.PP

.SS "void MPU6050::setIntFIFOBufferOverflowEnabled (boolenabled)"
Set FIFO Buffer Overflow interrupt enabled status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetIntFIFOBufferOverflowEnabled()\fP 
.PP
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_FIFO_OFLOW_BIT 
.RE
.PP

.SS "void MPU6050::setIntFreefallEnabled (boolenabled)"
Set Free Fall interrupt enabled status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetIntFreefallEnabled()\fP 
.PP
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_FF_BIT 
.RE
.PP

.SS "void MPU6050::setIntI2CMasterEnabled (boolenabled)"
Set I2C Master interrupt enabled status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetIntI2CMasterEnabled()\fP 
.PP
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_I2C_MST_INT_BIT 
.RE
.PP

.SS "void MPU6050::setIntMotionEnabled (boolenabled)"
Set Motion Detection interrupt enabled status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetIntMotionEnabled()\fP 
.PP
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_MOT_BIT 
.RE
.PP

.SS "void MPU6050::setIntZeroMotionEnabled (boolenabled)"
Set Zero Motion Detection interrupt enabled status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New interrupt enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetIntZeroMotionEnabled()\fP 
.PP
MPU6050_RA_INT_ENABLE 
.PP
MPU6050_INTERRUPT_ZMOT_BIT 
.RE
.PP

.SS "void MPU6050::setMasterClockSpeed (uint8_tspeed)"
Set I2C master clock speed\&.  speed Current I2C master clock speed 
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_CTRL 
.RE
.PP

.SS "void MPU6050::setMotionDetectionCounterDecrement (uint8_tdecrement)"
Set Motion detection counter decrement configuration\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdecrement\fP New decrement configuration value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetMotionDetectionCounterDecrement()\fP 
.PP
MPU6050_RA_MOT_DETECT_CTRL 
.PP
MPU6050_DETECT_MOT_COUNT_BIT 
.RE
.PP

.SS "void MPU6050::setMotionDetectionDuration (uint8_tduration)"
Set motion detection event duration threshold\&. 
.PP
\fBParameters:\fP
.RS 4
\fIduration\fP New motion detection duration threshold value (LSB = 1ms) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetMotionDetectionDuration()\fP 
.PP
MPU6050_RA_MOT_DUR 
.RE
.PP

.SS "void MPU6050::setMotionDetectionThreshold (uint8_tthreshold)"
Set free-fall event acceleration threshold\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthreshold\fP New motion detection acceleration threshold value (LSB = 2mg) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetMotionDetectionThreshold()\fP 
.PP
MPU6050_RA_MOT_THR 
.RE
.PP

.SS "void MPU6050::setMultiMasterEnabled (boolenabled)"
Set multi-master enabled value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New multi-master enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetMultiMasterEnabled()\fP 
.PP
MPU6050_RA_I2C_MST_CTRL 
.RE
.PP

.SS "void MPU6050::setRate (uint8_trate)"
Set gyroscope sample rate divider\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrate\fP New sample rate divider 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetRate()\fP 
.PP
MPU6050_RA_SMPLRT_DIV 
.RE
.PP

.SS "void MPU6050::setSlave0FIFOEnabled (boolenabled)"
Set Slave 0 FIFO enabled value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New Slave 0 FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlave0FIFOEnabled()\fP 
.PP
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "void MPU6050::setSlave1FIFOEnabled (boolenabled)"
Set Slave 1 FIFO enabled value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New Slave 1 FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlave1FIFOEnabled()\fP 
.PP
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "void MPU6050::setSlave2FIFOEnabled (boolenabled)"
Set Slave 2 FIFO enabled value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New Slave 2 FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlave2FIFOEnabled()\fP 
.PP
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "void MPU6050::setSlave3FIFOEnabled (boolenabled)"
Set Slave 3 FIFO enabled value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New Slave 3 FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlave3FIFOEnabled()\fP 
.PP
MPU6050_RA_MST_CTRL 
.RE
.PP

.SS "void MPU6050::setSlave4Address (uint8_taddress)"
Set the I2C address of Slave 4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIaddress\fP New address for Slave 4 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlave4Address()\fP 
.PP
MPU6050_RA_I2C_SLV4_ADDR 
.RE
.PP

.SS "void MPU6050::setSlave4Enabled (boolenabled)"
Set the enabled value for Slave 4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New enabled value for Slave 4 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlave4Enabled()\fP 
.PP
MPU6050_RA_I2C_SLV4_CTRL 
.RE
.PP

.SS "void MPU6050::setSlave4InterruptEnabled (boolenabled)"
Set the enabled value for Slave 4 transaction interrupts\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New enabled value for Slave 4 transaction interrupts\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlave4InterruptEnabled()\fP 
.PP
MPU6050_RA_I2C_SLV4_CTRL 
.RE
.PP

.SS "void MPU6050::setSlave4MasterDelay (uint8_tdelay)"
Set Slave 4 master delay value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdelay\fP New Slave 4 master delay value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlave4MasterDelay()\fP 
.PP
MPU6050_RA_I2C_SLV4_CTRL 
.RE
.PP

.SS "void MPU6050::setSlave4OutputByte (uint8_tdata)"
Set new byte to write to Slave 4\&. This register stores the data to be written into the Slave 4\&. If I2C_SLV4_RW is set 1 (set to read), this register has no effect\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP New byte to write to Slave 4 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV4_DO 
.RE
.PP

.SS "void MPU6050::setSlave4Register (uint8_treg)"
Set the active internal register for Slave 4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIreg\fP New active register for Slave 4 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlave4Register()\fP 
.PP
MPU6050_RA_I2C_SLV4_REG 
.RE
.PP

.SS "void MPU6050::setSlave4WriteMode (boolmode)"
Set write mode for the Slave 4\&. 
.PP
\fBParameters:\fP
.RS 4
\fImode\fP New write mode for Slave 4 (0 = register address + data, 1 = data only) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlave4WriteMode()\fP 
.PP
MPU6050_RA_I2C_SLV4_CTRL 
.RE
.PP

.SS "void MPU6050::setSlaveAddress (uint8_tnum, uint8_taddress)"
Set the I2C address of the specified slave (0-3)\&. 
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.br
\fIaddress\fP New address for specified slave 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlaveAddress()\fP 
.PP
MPU6050_RA_I2C_SLV0_ADDR 
.RE
.PP

.SS "void MPU6050::setSlaveDataLength (uint8_tnum, uint8_tlength)"
Set number of bytes to read for the specified slave (0-3)\&. 
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.br
\fIlength\fP Number of bytes to read for specified slave 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlaveDataLength()\fP 
.PP
MPU6050_RA_I2C_SLV0_CTRL 
.RE
.PP

.SS "void MPU6050::setSlaveDelayEnabled (uint8_tnum, boolenabled)"
Set slave delay enabled status\&. 
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-4) 
.br
\fIenabled\fP New slave delay enabled status\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_MST_DELAY_CTRL 
.PP
MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT 
.RE
.PP

.SS "void MPU6050::setSlaveEnabled (uint8_tnum, boolenabled)"
Set the enabled value for the specified slave (0-3)\&. 
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.br
\fIenabled\fP New enabled value for specified slave 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlaveEnabled()\fP 
.PP
MPU6050_RA_I2C_SLV0_CTRL 
.RE
.PP

.SS "void MPU6050::setSlaveOutputByte (uint8_tnum, uint8_tdata)"
Write byte to Data Output container for specified slave\&. This register holds the output data written into Slave when Slave is set to write mode\&. For further information regarding Slave control, please refer to Registers 37 to 39 and immediately following\&. 
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.br
\fIdata\fP Byte to write 
.RE
.PP
\fBSee also:\fP
.RS 4
MPU6050_RA_I2C_SLV0_DO 
.RE
.PP

.SS "void MPU6050::setSlaveReadWriteTransitionEnabled (boolenabled)"
Set slave read/write transition enabled value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New slave read/write transition enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlaveReadWriteTransitionEnabled()\fP 
.PP
MPU6050_RA_I2C_MST_CTRL 
.RE
.PP

.SS "void MPU6050::setSlaveRegister (uint8_tnum, uint8_treg)"
Set the active internal register for the specified slave (0-3)\&. 
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.br
\fIreg\fP New active register for specified slave 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlaveRegister()\fP 
.PP
MPU6050_RA_I2C_SLV0_REG 
.RE
.PP

.SS "void MPU6050::setSlaveWordByteSwap (uint8_tnum, boolenabled)"
Set word pair byte-swapping enabled for the specified slave (0-3)\&. 
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.br
\fIenabled\fP New word pair byte-swapping enabled value for specified slave 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlaveWordByteSwap()\fP 
.PP
MPU6050_RA_I2C_SLV0_CTRL 
.RE
.PP

.SS "void MPU6050::setSlaveWordGroupOffset (uint8_tnum, boolenabled)"
Set word pair grouping order offset for the specified slave (0-3)\&. 
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.br
\fIenabled\fP New word pair grouping order offset for specified slave 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlaveWordGroupOffset()\fP 
.PP
MPU6050_RA_I2C_SLV0_CTRL 
.RE
.PP

.SS "void MPU6050::setSlaveWriteMode (uint8_tnum, boolmode)"
Set write mode for the specified slave (0-3)\&. 
.PP
\fBParameters:\fP
.RS 4
\fInum\fP Slave number (0-3) 
.br
\fImode\fP New write mode for specified slave (0 = register address + data, 1 = data only) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSlaveWriteMode()\fP 
.PP
MPU6050_RA_I2C_SLV0_CTRL 
.RE
.PP

.SS "void MPU6050::setSleepEnabled (boolenabled)"
Set sleep mode status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New sleep mode enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetSleepEnabled()\fP 
.PP
MPU6050_RA_PWR_MGMT_1 
.PP
MPU6050_PWR1_SLEEP_BIT 
.RE
.PP

.SS "void MPU6050::setTempFIFOEnabled (boolenabled)"
Set temperature FIFO enabled value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New temperature FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetTempFIFOEnabled()\fP 
.PP
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "void MPU6050::setTempSensorEnabled (boolenabled)"
Set temperature sensor enabled status\&. Note: this register stores the \fIdisabled\fP value, but for consistency with the rest of the code, the function is named and used with standard true/false values to indicate whether the sensor is enabled or disabled, respectively\&.
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New temperature sensor enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetTempSensorEnabled()\fP 
.PP
MPU6050_RA_PWR_MGMT_1 
.PP
MPU6050_PWR1_TEMP_DIS_BIT 
.RE
.PP

.SS "void MPU6050::setWaitForExternalSensorEnabled (boolenabled)"
Set wait-for-external-sensor-data enabled value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New wait-for-external-sensor-data enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetWaitForExternalSensorEnabled()\fP 
.PP
MPU6050_RA_I2C_MST_CTRL 
.RE
.PP

.SS "void MPU6050::setWakeCycleEnabled (boolenabled)"
Set wake cycle enabled status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New sleep mode enabled status 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetWakeCycleEnabled()\fP 
.PP
MPU6050_RA_PWR_MGMT_1 
.PP
MPU6050_PWR1_CYCLE_BIT 
.RE
.PP

.SS "void MPU6050::setXGyroFIFOEnabled (boolenabled)"
Set gyroscope X-axis FIFO enabled value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New gyroscope X-axis FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetXGyroFIFOEnabled()\fP 
.PP
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "void MPU6050::setYGyroFIFOEnabled (boolenabled)"
Set gyroscope Y-axis FIFO enabled value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New gyroscope Y-axis FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetYGyroFIFOEnabled()\fP 
.PP
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "void MPU6050::setZeroMotionDetectionDuration (uint8_tduration)"
Set zero motion detection event duration threshold\&. 
.PP
\fBParameters:\fP
.RS 4
\fIduration\fP New zero motion detection duration threshold value (LSB = 1ms) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetZeroMotionDetectionDuration()\fP 
.PP
MPU6050_RA_ZRMOT_DUR 
.RE
.PP

.SS "void MPU6050::setZeroMotionDetectionThreshold (uint8_tthreshold)"
Set zero motion detection event acceleration threshold\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthreshold\fP New zero motion detection acceleration threshold value (LSB = 2mg) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetZeroMotionDetectionThreshold()\fP 
.PP
MPU6050_RA_ZRMOT_THR 
.RE
.PP

.SS "void MPU6050::setZGyroFIFOEnabled (boolenabled)"
Set gyroscope Z-axis FIFO enabled value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIenabled\fP New gyroscope Z-axis FIFO enabled value 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetZGyroFIFOEnabled()\fP 
.PP
MPU6050_RA_FIFO_EN 
.RE
.PP

.SS "void MPU6050::switchSPIEnabled (boolenabled)"
Switch from I2C to SPI mode (MPU-6000 only) If this is set, the primary SPI interface will be enabled in place of the disabled primary I2C interface\&. 
.SS "bool MPU6050::testConnection ()"
Verify the I2C connection\&. Make sure the device is connected and responds as expected\&. 
.PP
\fBReturns:\fP
.RS 4
True if connection is valid, false otherwise 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Cubeception from the source code\&.
